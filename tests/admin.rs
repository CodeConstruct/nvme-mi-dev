// SPDX-License-Identifier: GPL-3.0-only
/*
 * Copyright (c) 2025 Code Construct
 */
mod common;

#[rustfmt::skip]
const RESP_INVALID_COMMAND: [u8; 11] = [
    0x90, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00,
    0xe8, 0xdb, 0x23, 0x92
];

#[rustfmt::skip]
const RESP_INVALID_PARAMETER: [u8; 11] = [
    0x90, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00,
    0x22, 0x63, 0x23, 0x8b
];

#[rustfmt::skip]
const RESP_INVALID_COMMAND_SIZE: [u8; 11] = [
    0x90, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00,
    0x9a, 0xc9, 0x66, 0x56
];

#[rustfmt::skip]
const RESP_ADMIN_SUCCESS: [u8; 23] = [
    0x90, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00,
    0x30, 0xd5, 0xa2, 0x9b
];

#[rustfmt::skip]
const RESP_ADMIN_STATUS_INVALID_FIELD: [u8; 23] = [
    0x90, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x05, 0x80,
    0x94, 0x8f, 0xde, 0x57,
];

mod prohibited {
    use super::RESP_INVALID_COMMAND;
    use crate::common::{DeviceType, ExpectedRespChannel, new_device, setup};
    use mctp::MsgIC;

    #[test]
    fn delete_io_submission_queue() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xef, 0x00, 0xd6, 0x6a
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }
}

mod identify {
    use super::RESP_INVALID_COMMAND_SIZE;
    use super::RESP_INVALID_PARAMETER;
    use crate::RESP_ADMIN_STATUS_INVALID_FIELD;
    use crate::common::DeviceType;
    use crate::common::ExpectedField;
    use crate::common::ExpectedRespChannel;
    use crate::common::RelaxedRespChannel;
    use crate::common::TestDevice;
    use crate::common::new_device;
    use crate::common::setup;
    use mctp::MsgIC;

    #[rustfmt::skip]
    const RESP_ADMIN_STATUS_INVALID_NAMESPACE: [u8; 23] = [
        0x90, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x17, 0x80,
        0xfb, 0x4e, 0x5e, 0x4f
    ];

    #[test]
    fn controller_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing SQE DWORD 15

            // MIC
            0x8d, 0xc8, 0x56, 0xeb
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Populated request data
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x02, 0x66, 0xb9, 0x3b
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_unnatural_dofst() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Unnatural DOFST
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xb7, 0xc3, 0x93, 0x30
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_large_dofst() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Large DOFST
            0x00, 0x10, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x9e, 0x2c, 0x6b, 0xe9
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_unnatural_dlen() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Unnatural DLEN
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xf2, 0xe2, 0x2e, 0xc9
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_large_dlen() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Large DLEN
            0x00, 0x00, 0x00, 0x00,
            0x04, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x6c, 0x38, 0x61, 0x22
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_uncontained_range() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST + DLEN > 4096
            0x04, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x23, 0x19, 0x67, 0x94
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_improper_dlen() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Improper DLEN
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x4e, 0x59, 0xe2, 0xfa
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x9c, 0xd6, 0x53, 0xed
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (23, &[0x31, 0x30, 0x30, 0x30]), // SN
            (43, &[0x4d, 0x49, 0x44, 0x45, 0x56]), // MN
            (83, &[0x30, 0x30, 0x2e, 0x30, 0x30, 0x2e, 0x30, 0x31]), // FR
            (95, &[0x01]), // CMIC
            (98, &[0x00, 0x00]), // CNTLID
            (130, &[0x01]), // CNTRLTYPE
            (272, &[0x01]), // NVMSR
            (274, &[0x03]), // MEC
            (285, &[0x57, 0x01]), // WCTEMP
            (287, &[0x57, 0x01]), // CCTEMP
            (535, &[0x04]), // NN
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn nvm_subsystem_controller_list() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x13, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x0a, 0x21, 0x8b, 0x19
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x01, 0x00]),
            (21, &[0x00, 0x00]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_invalid_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x12, 0x14, 0x1c, 0x57
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_NAMESPACE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    #[ignore = "not yet implemented: Deal with broadcast NSID"]
    fn namespace_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xdc, 0xee, 0xe8, 0xf2
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_unallocated_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x49, 0xb0, 0xa7, 0x22
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_NAMESPACE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_broadcast() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xdc, 0xee, 0xe8, 0xf2
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19 + 130, &[0x09]), // LBADS
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_inactive() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x49, 0xb0, 0xa7, 0x22
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_active() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x49, 0xb0, 0xa7, 0x22
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            (27, &[0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            (35, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            (147, &[0x00, 0x00, 0x09, 0x00])
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn active_namespace_id_list_empty() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xff, 0xe7, 0x6f, 0x26
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn active_namespace_id_list_populated() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xff, 0xe7, 0x6f, 0x26
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x01, 0x00, 0x00, 0x00]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn active_namespace_id_list_constrained_empty() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xa4, 0x43, 0xd4, 0x53
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identification_descriptor_list_bad_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xfe, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xe4, 0x7b, 0x6f, 0x4c
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_NAMESPACE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identification_descriptor_list_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xbf, 0xdf, 0xd4, 0x39
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_NAMESPACE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identification_descriptor_list_invalid_nsid_zero() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x71, 0x25, 0x20, 0x9c
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_NAMESPACE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identification_descriptor_list_invalid_nsid_exceeds() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x9c, 0xc9, 0xec, 0x02
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_NAMESPACE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identification_descriptor_list_unallocated_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xc7, 0x6d, 0x57, 0x77
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_NAMESPACE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identification_descriptor_list() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x2a, 0x81, 0x9b, 0xe9
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x03]),
            (20, &[0x10]),
            (39, &[0x04]),
            (40, &[0x01]),
            (41, &[0x00]),
            (42, &[0x00]),
            (43, &[0x00]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identify_large_size() {
        setup();

        let mut t = TestDevice::new();
        let ctlrid = t.subsys.add_controller(t.ppid).unwrap();
        // TODO lbads is assumed from current Namespace::new()
        let lbads = 9;
        let blocks = u64::MAX;
        let nvmcap = (blocks as u128) * 2_u128.pow(lbads);
        let nsid = t.subsys.add_namespace(blocks).unwrap();
        let ctrl = t.subsys.controller_mut(ctlrid);
        ctrl.attach_namespace(nsid).unwrap();

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x49, 0xb0, 0xa7, 0x22
        ];

        let blocks_repr = blocks.to_le_bytes();
        let nvmcap_repr = nvmcap.to_le_bytes();

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            // NSZE
            (19, &blocks_repr),
            // NCAP
            (19+8, &blocks_repr),
            // NVMCAP
            (19+48, &nvmcap_repr),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            t.mep
                .handle_async(&mut t.subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn allocated_namespace_id_list_populated() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x69, 0x10, 0xb7, 0xd2
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x01, 0x00, 0x00, 0x00]),
            (23, &[0x00, 0x00, 0x00, 0x00])
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn allocated_namespace_id_list_constrained_empty() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x32, 0xb4, 0x0c, 0xa7
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn allocated_namespace_id_list_constrained_bad_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xfe, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xfc, 0x4e, 0xf8, 0x02
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn allocated_namespace_id_list_constrained_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xa7, 0xea, 0x43, 0x77
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn identify_namespace_for_allocated_namespace_id_invalid_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x11, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xe7, 0xd2, 0xf8, 0x68
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_NAMESPACE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn identify_namespace_for_allocated_namespace_id_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x11, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x29, 0x28, 0x0c, 0xcd
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_NAMESPACE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn identify_namespace_for_allocated_namespace_id_unallocated_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x11, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x51, 0x9a, 0x8f, 0x83
        ];

        #[rustfmt::skip]
        const RESP_DATA: [u8; 19] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00
        ];

        const RESP_LEN: usize = 4119;
        let mut resp: [u8; RESP_LEN] = [0; RESP_LEN];
        resp[..RESP_DATA.len()].copy_from_slice(&RESP_DATA);
        resp[(RESP_LEN - 4)..].copy_from_slice(&[0x87, 0xd7, 0x1f, 0xaa]);

        let resp = ExpectedRespChannel::new(&resp);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn identify_namespace_for_allocated_namespace_id_inactive_nsid() {
        setup();

        let lbads = 9u8;
        let blocks = 1024u64;
        let nvmcap = (blocks as u128) * 2_u128.pow(lbads as u32);

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x11, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xbc, 0x76, 0x43, 0x1d
        ];

        let blocks_repr = blocks.to_le_bytes();
        let nvmcap_repr = nvmcap.to_le_bytes();
        let lbads_repr = [lbads];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            // NSZE
            (19, &blocks_repr),
            // NCAP
            (19+8, &blocks_repr),
            // NVMCAP
            (19+48, &nvmcap_repr),
            // LBAF0_LBADS
            (19+130, &lbads_repr)
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn identify_namespace_for_allocated_namespace_id_active_nsid() {
        setup();

        let lbads = 9u8;
        let blocks = 1024u64;
        let nvmcap = (blocks as u128) * 2_u128.pow(lbads as u32);

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x11, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xbc, 0x76, 0x43, 0x1d
        ];

        let blocks_repr = blocks.to_le_bytes();
        let nvmcap_repr = nvmcap.to_le_bytes();
        let lbads_repr = [lbads];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            // NSZE
            (19, &blocks_repr),
            // NCAP
            (19+8, &blocks_repr),
            // NVMCAP
            (19+48, &nvmcap_repr),
            // LBAF0_LBADS
            (19+130, &lbads_repr)
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_attached_controller_list_invalid_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x12, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x84, 0xe3, 0xc4, 0xa3
        ];

        #[rustfmt::skip]
        const RESP_DATA: [u8; 19] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00
        ];

        const RESP_LEN: usize = 4119;
        let mut resp: [u8; RESP_LEN] = [0; RESP_LEN];
        resp[..RESP_DATA.len()].copy_from_slice(&RESP_DATA);
        resp[(RESP_LEN - 4)..].copy_from_slice(&[0x87, 0xd7, 0x1f, 0xaa]);

        let resp = ExpectedRespChannel::new(&resp);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_attached_controller_list_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x12, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x4a, 0x19, 0x30, 0x06
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_FIELD);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_attached_controller_list_unallocated_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x12, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x32, 0xab, 0xb3, 0x48
        ];

        #[rustfmt::skip]
        const RESP_DATA: [u8; 19] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00
        ];

        const RESP_LEN: usize = 4119;
        let mut resp: [u8; RESP_LEN] = [0; RESP_LEN];
        resp[..RESP_DATA.len()].copy_from_slice(&RESP_DATA);
        resp[(RESP_LEN - 4)..].copy_from_slice(&[0x87, 0xd7, 0x1f, 0xaa]);

        let resp = ExpectedRespChannel::new(&resp);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_attached_controller_list_inactive_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x12, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xdf, 0x47, 0x7f, 0xd6
        ];

        #[rustfmt::skip]
        const RESP_DATA: [u8; 19] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00
        ];

        const RESP_LEN: usize = 4119;
        let mut resp: [u8; RESP_LEN] = [0; RESP_LEN];
        resp[..RESP_DATA.len()].copy_from_slice(&RESP_DATA);
        resp[(RESP_LEN - 4)..].copy_from_slice(&[0x87, 0xd7, 0x1f, 0xaa]);

        let resp = ExpectedRespChannel::new(&resp);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_attached_controller_list_active_nsid_unconstrained() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x12, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xdf, 0x47, 0x7f, 0xd6
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[1, 0]),
            (19 + 2, &[0, 0]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_attached_controller_list_active_nsid_constrained() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x12, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x6b, 0xa9, 0x6a, 0x8a
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0, 0]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn secondary_controller_list() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x15, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x3d, 0x35, 0x1f, 0x8a
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }
}

mod get_log_page {
    use mctp::MsgIC;
    use nvme_mi_dev::{
        ManagementEndpoint, PciePort, PortType, Subsystem, SubsystemInfo, Temperature, TwoWirePort,
    };

    use crate::{
        RESP_ADMIN_STATUS_INVALID_FIELD, RESP_INVALID_COMMAND_SIZE, RESP_INVALID_PARAMETER,
        common::{
            DeviceType, ExpectedField, ExpectedRespChannel, RelaxedRespChannel, new_device, setup,
        },
    };

    #[test]
    fn get_supported_log_pages_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing SQE DWORD 15

            // MIC
            0x43, 0x2e, 0xee, 0x4b
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn get_supported_log_pages_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xae, 0xb8, 0x7e, 0x6f
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn get_supported_log_pages_bad_ctlid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0xff, 0xff,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x29, 0xe2, 0x53, 0x0a
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn get_supported_log_pages() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x2d, 0x55, 0x31, 0xde
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[1, 0, 0, 0]),
            (19 + 8, &[1, 0, 0, 0]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0xff, 0x03,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing SQE DWORD 15

            // MIC
            0x07, 0x90, 0x7b, 0xd3
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x85, 0x81, 0x51, 0x79
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_bad_ctlid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0xff, 0xff,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x80, 0x60, 0xc4, 0x3b
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_bad_ot() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x80, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x52, 0x60, 0xae, 0xf3
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_FIELD);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_bad_lpo() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x04, 0x02, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x6d, 0x81, 0xbf, 0xe6
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_FIELD);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_bad_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xfe, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x11, 0x89, 0xe9, 0x3f
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_FIELD);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x84, 0xd7, 0xa6, 0xef
        ];

        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (15, &[0x00, 0x00, 0x01, 0x00]),
            (19, &[0x00, 0x25, 0x01, 0x64]),
            (19 + 4, &[0x05, 0x26, 0x00, 0x00]),
            (19 + 200, &[0x25, 0x01, 0x25, 0x01]),
            (19 + 204, &[0x25, 0x01, 0x25, 0x01]),
            (19 + 208, &[0x25, 0x01, 0x25, 0x01]),
            (19 + 212, &[0x25, 0x01, 0x25, 0x01]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_temp_low() {
        setup();

        let mut subsys = Subsystem::new(SubsystemInfo::invalid());
        let ppid = subsys.add_port(PortType::Pcie(PciePort::new())).unwrap();
        let ctlrid = subsys.add_controller(ppid).unwrap();
        let twpid = subsys
            .add_port(PortType::TwoWire(TwoWirePort::new()))
            .unwrap();
        let mut mep = ManagementEndpoint::new(twpid);
        let ctlr = subsys.controller_mut(ctlrid);
        ctlr.set_temperature(Temperature::Kelvin(212));

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x84, 0xd7, 0xa6, 0xef
        ];

        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (15, &[0x00, 0x00, 0x01, 0x00]),
            (19, &[0x02, 0xd4, 0x00, 0x64]),
            (19 + 4, &[0x05, 0x26, 0x00, 0x00]),
            (19 + 200, &[0xd4, 0x00, 0xd4, 0x00]),
            (19 + 204, &[0xd4, 0x00, 0xd4, 0x00]),
            (19 + 208, &[0xd4, 0x00, 0xd4, 0x00]),
            (19 + 212, &[0xd4, 0x00, 0xd4, 0x00]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn error_information_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x0f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing DWORD 15

            // MIC
            0x01, 0xbd, 0xa2, 0xa3
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn error_information_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x0f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x6f, 0x7d, 0xfd, 0x6d
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn error_information() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x0f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x44, 0x77, 0x3b, 0x9e
        ];

        #[rustfmt::skip]
        const RESP: [u8; 87] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0xb6, 0xce, 0x4e, 0x7f
        ];

        let resp = ExpectedRespChannel::new(&RESP);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn feature_identifiers_supported_and_effects_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x12, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing SQE DWORD 15

            // MIC
            0xfa, 0x21, 0x62, 0x5f
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn feature_identifiers_supported_and_effects_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x12, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x1d, 0x31, 0x5a, 0x2b
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn feature_identifiers_supported_and_effects() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x12, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xbb, 0xa2, 0xe9, 0x2a
        ];

        let resp_fields: Vec<ExpectedField> = vec![(0, &[0x90]), (15, &[0x00, 0x00, 0x01, 0x00])];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn sanitize_status_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x81, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing SQE DWORD 15

            // MIC
            0x7d, 0x24, 0xfd, 0x19
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        })
    }

    #[test]
    fn sanitize_status_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x81, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x78, 0x23, 0x9c, 0xb5
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        })
    }

    #[test]
    fn sanitize_status() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x81, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xfb, 0x1e, 0x73, 0x1e
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (17, &[0x01]),
            (19, &[0xff, 0xff]),
            (19 + 8, &[0xff, 0xff, 0xff, 0xff]),
            (19 + 12, &[0xff, 0xff, 0xff, 0xff]),
            (19 + 16, &[0xff, 0xff, 0xff, 0xff]),
            (19 + 20, &[0xff, 0xff, 0xff, 0xff]),
            (19 + 24, &[0xff, 0xff, 0xff, 0xff]),
            (19 + 28, &[0xff, 0xff, 0xff, 0xff]),
            (19 + 32, &[0xff, 0xff, 0xff, 0xff]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        })
    }
}

mod namespace_management {
    use mctp::MsgIC;

    use crate::{
        RESP_INVALID_COMMAND_SIZE,
        common::{DeviceType, ExpectedRespChannel, new_device, setup},
    };

    #[test]
    fn create_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x0d, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Missing request data

            // MIC
            0x17, 0xc6, 0x4c, 0x65
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn create_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x0d, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0x5d, 0x13, 0x77, 0x61];

        let mut req = [0u8; { 71 + 4096 + 1 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn create() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 83] = [
            0x10, 0x00, 0x00,
            0x0d, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Request Data
            // NSZE
            0x00, 0x10, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // NCAP
            0x00, 0x10, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0xd1, 0xf0, 0x5b, 0xd1];

        let mut req = [0u8; { 71 + 4096 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        #[rustfmt::skip]
        const RESP: [u8; 23] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00,
            0x00, 0x01, 0xd3, 0xaa
        ];

        let resp = ExpectedRespChannel::new(&RESP);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn delete_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x0d, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing CQE DWORD 15

            // MIC
            0x53, 0x40, 0x39, 0x48
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn delete_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x0d, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x95, 0xc4, 0x55, 0x8b
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn delete_unallocated() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x0d, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xc2, 0xa0, 0xb8, 0xaa
        ];

        #[rustfmt::skip]
        const RESP: [u8; 23] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x2d, 0x82,
            0xe9, 0x0b, 0x0b, 0x65];

        let resp = ExpectedRespChannel::new(&RESP);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn delete_allocated() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x0d, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xc2, 0xa0, 0xb8, 0xaa
        ];

        #[rustfmt::skip]
        const RESP: [u8; 23] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00,
            0x00, 0x01, 0xd3, 0xaa
        ];

        let resp = ExpectedRespChannel::new(&RESP);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn delete_all() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x0d, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x57, 0xfe, 0xf7, 0x7a
        ];

        #[rustfmt::skip]
        const RESP: [u8; 23] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00,
            0x92, 0x9f, 0x3d, 0x4f
        ];

        let resp = ExpectedRespChannel::new(&RESP);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }
}

mod namespace_attachment {
    use mctp::MsgIC;

    use crate::{
        RESP_INVALID_COMMAND_SIZE, RESP_INVALID_PARAMETER,
        common::{DeviceType, ExpectedRespChannel, new_device, setup},
    };

    #[test]
    fn attach_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0x4e, 0x9c, 0x58, 0x64];

        let mut req = [0u8; { 71 + 4096 - 4 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn attach_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0x12, 0xdb, 0x3c, 0x87];

        let mut req = [0u8; { 71 + 4096 + 4 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn attach_too_many_nsids() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x01, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            0x00, 0x08, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0x8b, 0x24, 0x56, 0x55];

        let mut req = [0u8; { 71 + 4096 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn attach_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x01, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            0x01, 0x00, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0x21, 0xf1, 0x06, 0x35];

        let mut req = [0u8; { 71 + 4096 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn attach_unrecognised_controller() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x01, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            0x01, 0x00, 0x01, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0x31, 0x70, 0xa4, 0x05];

        let mut req = [0u8; { 71 + 4096 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        #[rustfmt::skip]
        const RESP: [u8; 23] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x39, 0x82,
            0xb4, 0x9b, 0x44, 0x14
        ];

        let resp = ExpectedRespChannel::new(&RESP);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn attach_already_attached() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x01, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            0x01, 0x00, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0xac, 0x85, 0xf8, 0xf9];

        let mut req = [0u8; { 71 + 4096 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        #[rustfmt::skip]
        const RESP: [u8; 23] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x31, 0x82,
            0x0c, 0x58, 0x50, 0x89
        ];

        let resp = ExpectedRespChannel::new(&RESP);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn attach() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x01, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            0x01, 0x00, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0xac, 0x85, 0xf8, 0xf9];

        let mut req = [0u8; { 71 + 4096 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        #[rustfmt::skip]
        const RESP: [u8; 23] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00,
            0x00, 0x01, 0xd3, 0xaa
        ];

        let resp = ExpectedRespChannel::new(&RESP);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn detach_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0x00, 0x43, 0x71, 0x3f];

        let mut req = [0u8; { 71 + 4096 - 4 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn detach_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0xb8, 0x07, 0xcd, 0x13];

        let mut req = [0u8; { 71 + 4096 + 4 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn detach_too_many_nsids() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            0x00, 0x08, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0x71, 0x25, 0x2c, 0xc9];

        let mut req = [0u8; { 71 + 4096 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn detach_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            0x01, 0x00, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0xdb, 0xf0, 0x7c, 0xa9];

        let mut req = [0u8; { 71 + 4096 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn detach_unrecognised_controller() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            0x01, 0x00, 0x01, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0xcb, 0x71, 0xde, 0x99];

        let mut req = [0u8; { 71 + 4096 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        #[rustfmt::skip]
        const RESP: [u8; 23] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x39, 0x82,
            0xb4, 0x9b, 0x44, 0x14
        ];

        let resp = ExpectedRespChannel::new(&RESP);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn detach_not_attached() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a0a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            0x01, 0x00, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0x56, 0x84, 0x82, 0x65];

        let mut req = [0u8; { 71 + 4096 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        #[rustfmt::skip]
        const RESP: [u8; 23] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x35, 0x82,
            0xd0, 0x39, 0xda, 0xc7
        ];

        let resp = ExpectedRespChannel::new(&RESP);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn detach() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ_DATA: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x15, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            0x01, 0x00, 0x00, 0x00,
        ];

        const REQ_MIC: [u8; 4] = [0x56, 0x84, 0x82, 0x65];

        let mut req = [0u8; { 71 + 4096 }];
        let len = req.len();
        req[..REQ_DATA.len()].copy_from_slice(&REQ_DATA);
        req[{ len - REQ_MIC.len() }..].copy_from_slice(&REQ_MIC);

        #[rustfmt::skip]
        const RESP: [u8; 23] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00,
            0x00, 0x01, 0xd3, 0xaa
        ];

        let resp = ExpectedRespChannel::new(&RESP);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &req, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }
}

mod sanitize {
    use mctp::MsgIC;

    use crate::{
        RESP_ADMIN_SUCCESS, RESP_INVALID_COMMAND_SIZE, RESP_INVALID_PARAMETER,
        common::{DeviceType, ExpectedRespChannel, new_device, setup},
    };

    #[test]
    fn short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x84, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x0a, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing SQE DWORD 15

            // MIC
            0x38, 0xdd, 0xc5, 0x6f
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x84, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x0a, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x60, 0x57, 0x08, 0xd9
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn block_erase_unrestricted_exit() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x84, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x0a, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x36, 0x65, 0x65, 0xd9
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_SUCCESS);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn crypto_erase_unrestricted_exit() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x84, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x0c, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x01, 0x71, 0xf1, 0x4a
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_SUCCESS);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn overwrite_unrestricted_exit() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x84, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x0b, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xb8, 0xa7, 0x2a, 0x63
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_SUCCESS);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn ndi_ndas() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x84, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x0b, 0x02, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xc8, 0x47, 0x8d, 0x88
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn exit_failure_mode() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x84, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x10, 0xed, 0x7a, 0xd2
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_SUCCESS);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }
}

mod format_nvm {
    use mctp::MsgIC;

    use crate::{
        RESP_ADMIN_SUCCESS, RESP_INVALID_COMMAND_SIZE, RESP_INVALID_PARAMETER,
        common::{DeviceType, ExpectedRespChannel, new_device, setup},
    };

    #[test]
    fn short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x80, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xa7, 0x2b, 0x0b, 0x87
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        })
    }

    #[test]
    fn long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x80, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x18, 0x47, 0x6d, 0x16
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        })
    }

    #[test]
    fn invalid_controller() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x80, 0x00, 0x01, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x0f, 0x14, 0xe6, 0x14
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        })
    }

    #[test]
    fn invalid_secure_erase_strategy() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x80, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x08, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x7a, 0x05, 0xbd, 0xb8
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        })
    }

    #[test]
    fn invalid_lba_format_index() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x80, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x27, 0xdd, 0x59, 0xa2
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        })
    }

    #[test]
    fn unrecognised_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x80, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xd1, 0xad, 0x95, 0x56
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        })
    }

    #[test]
    fn no_operation() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1iN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x80, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xa9, 0x1f, 0x16, 0x18
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_SUCCESS);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        })
    }
}
