// SPDX-License-Identifier: GPL-3.0-only
/*
 * Copyright (c) 2025 Code Construct
 */
mod common;

#[rustfmt::skip]
const RESP_INVALID_COMMAND: [u8; 11] = [
    0x90, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00,
    0xe8, 0xdb, 0x23, 0x92
];

#[rustfmt::skip]
const RESP_INVALID_PARAMETER: [u8; 11] = [
    0x90, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00,
    0x22, 0x63, 0x23, 0x8b
];

#[rustfmt::skip]
const RESP_INVALID_COMMAND_SIZE: [u8; 11] = [
    0x90, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00,
    0x9a, 0xc9, 0x66, 0x56
];

mod prohibited {
    use super::RESP_INVALID_COMMAND;
    use crate::common::{DeviceType, ExpectedRespChannel, new_device, setup};
    use mctp::MsgIC;

    #[test]
    fn delete_io_submission_queue() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xef, 0x00, 0xd6, 0x6a
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }
}

mod identify {
    use super::RESP_INVALID_COMMAND_SIZE;
    use super::RESP_INVALID_PARAMETER;
    use crate::common::DeviceType;
    use crate::common::ExpectedField;
    use crate::common::ExpectedRespChannel;
    use crate::common::RelaxedRespChannel;
    use crate::common::TestDevice;
    use crate::common::new_device;
    use crate::common::setup;
    use mctp::MsgIC;

    #[test]
    fn controller_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing SQE DWORD 15

            // MIC
            0x8d, 0xc8, 0x56, 0xeb
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Populated request data
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x02, 0x66, 0xb9, 0x3b
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_unnatural_dofst() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Unnatural DOFST
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xb7, 0xc3, 0x93, 0x30
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_large_dofst() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Large DOFST
            0x00, 0x10, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x9e, 0x2c, 0x6b, 0xe9
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_unnatural_dlen() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Unnatural DLEN
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xf2, 0xe2, 0x2e, 0xc9
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_large_dlen() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Large DLEN
            0x00, 0x00, 0x00, 0x00,
            0x04, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x6c, 0x38, 0x61, 0x22
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_uncontained_range() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST + DLEN > 4096
            0x04, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x23, 0x19, 0x67, 0x94
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller_improper_dlen() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Improper DLEN
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x4e, 0x59, 0xe2, 0xfa
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn controller() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x9c, 0xd6, 0x53, 0xed
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (23, &[0x31, 0x30, 0x30, 0x30]), // SN
            (43, &[0x4d, 0x49, 0x44, 0x45, 0x56]), // MN
            (83, &[0x30, 0x30, 0x2e, 0x30, 0x30, 0x2e, 0x30, 0x31]), // FR
            (95, &[0x01]), // CMIC
            (98, &[0x00, 0x00]), // CNTLID
            (130, &[0x03]), // CNTRLTYPE
            (272, &[0x01]), // NVMSR
            (274, &[0x03]), // MEC
            (285, &[0x57, 0x01]), // WCTEMP
            (287, &[0x57, 0x01]), // CCTEMP
            (535, &[0x02]), // NN
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn nvm_subsystem_controller_list() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x13, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x0a, 0x21, 0x8b, 0x19
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x01, 0x00]),
            (21, &[0x00, 0x00]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_invalid_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x12, 0x14, 0x1c, 0x57
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    #[ignore = "not yet implemented: Deal with broadcast NSID"]
    fn namespace_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xdc, 0xee, 0xe8, 0xf2
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_unallocated_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x49, 0xb0, 0xa7, 0x22
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_inactive() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x49, 0xb0, 0xa7, 0x22
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_active() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x49, 0xb0, 0xa7, 0x22
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            (27, &[0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            (35, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            (147, &[0x00, 0x00, 0x09, 0x00])
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn active_namespace_id_list_empty() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xff, 0xe7, 0x6f, 0x26
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn active_namespace_id_list_populated() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xff, 0xe7, 0x6f, 0x26
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x01, 0x00, 0x00, 0x00]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn active_namespace_id_list_constrained_empty() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xa4, 0x43, 0xd4, 0x53
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identification_descriptor_list_bad_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xfe, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xe4, 0x7b, 0x6f, 0x4c
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identification_descriptor_list_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xbf, 0xdf, 0xd4, 0x39
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identification_descriptor_list_invalid_nsid_zero() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x71, 0x25, 0x20, 0x9c
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identification_descriptor_list_invalid_nsid_exceeds() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x9c, 0xc9, 0xec, 0x02
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identification_descriptor_list_unallocated_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xc7, 0x6d, 0x57, 0x77
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identification_descriptor_list() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x2a, 0x81, 0x9b, 0xe9
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x03]),
            (20, &[0x10]),
            (39, &[0x04]),
            (40, &[0x01]),
            (41, &[0x00]),
            (42, &[0x00]),
            (43, &[0x00]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn namespace_identify_large_size() {
        setup();

        let mut t = TestDevice::new();
        let ctlrid = t.subsys.add_controller(t.ppid).unwrap();
        // TODO lbads is assumed from current Namespace::new()
        let lbads = 9;
        let blocks = u64::MAX;
        let nvmcap = (blocks as u128) * 2_u128.pow(lbads);
        let nsid = t.subsys.add_namespace(blocks).unwrap();
        let ctrl = t.subsys.controller_mut(ctlrid);
        ctrl.attach_namespace(nsid).unwrap();

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x49, 0xb0, 0xa7, 0x22
        ];

        let blocks_repr = blocks.to_le_bytes();
        let nvmcap_repr = nvmcap.to_le_bytes();

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            // NSZE
            (19, &blocks_repr),
            // NCAP
            (19+8, &blocks_repr),
            // NVMCAP
            (19+48, &nvmcap_repr),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            t.mep
                .handle_async(&mut t.subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn allocated_namespace_id_list_populated() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x69, 0x10, 0xb7, 0xd2
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x01, 0x00, 0x00, 0x00]),
            (23, &[0x00, 0x00, 0x00, 0x00])
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn allocated_namespace_id_list_constrained_empty() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x32, 0xb4, 0x0c, 0xa7
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn allocated_namespace_id_list_constrained_bad_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xfe, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xfc, 0x4e, 0xf8, 0x02
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn allocated_namespace_id_list_constrained_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xa7, 0xea, 0x43, 0x77
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn secondary_controller_list() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x15, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x3d, 0x35, 0x1f, 0x8a
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }
}

mod get_log_page {
    use mctp::MsgIC;
    use nvme_mi_dev::{
        ManagementEndpoint, PciePort, PortType, Subsystem, SubsystemInfo, Temperature, TwoWirePort,
    };

    use crate::{
        RESP_INVALID_COMMAND_SIZE, RESP_INVALID_PARAMETER,
        common::{
            DeviceType, ExpectedField, ExpectedRespChannel, RelaxedRespChannel, new_device, setup,
        },
    };

    // Base v2.1, 5.1.12
    // Admin command response with SCT / SC set
    #[rustfmt::skip]
    const RESP_ADMIN_STATUS_INVALID_FIELD: [u8; 23] = [
        0x90, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x05, 0x80,
        0x94, 0x8f, 0xde, 0x57,
    ];

    #[test]
    fn get_supported_log_pages_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing SQE DWORD 15

            // MIC
            0x43, 0x2e, 0xee, 0x4b
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn get_supported_log_pages_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xae, 0xb8, 0x7e, 0x6f
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn get_supported_log_pages_bad_ctlid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0xff, 0xff,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x29, 0xe2, 0x53, 0x0a
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn get_supported_log_pages() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x2d, 0x55, 0x31, 0xde
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[1, 0, 0, 0]),
            (19 + 8, &[1, 0, 0, 0]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0xff, 0x03,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing SQE DWORD 15

            // MIC
            0x07, 0x90, 0x7b, 0xd3
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x85, 0x81, 0x51, 0x79
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_bad_ctlid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0xff, 0xff,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x80, 0x60, 0xc4, 0x3b
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_bad_ot() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x80, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x52, 0x60, 0xae, 0xf3
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_FIELD);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_bad_lpo() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x04, 0x02, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x6d, 0x81, 0xbf, 0xe6
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_FIELD);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_bad_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xfe, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x11, 0x89, 0xe9, 0x3f
        ];

        let resp = ExpectedRespChannel::new(&RESP_ADMIN_STATUS_INVALID_FIELD);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x84, 0xd7, 0xa6, 0xef
        ];

        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (15, &[0x00, 0x00, 0x01, 0x00]),
            (19, &[0x00, 0x25, 0x01, 0x64]),
            (19 + 4, &[0x05, 0x26, 0x00, 0x00]),
            (19 + 200, &[0x25, 0x01, 0x25, 0x01]),
            (19 + 204, &[0x25, 0x01, 0x25, 0x01]),
            (19 + 208, &[0x25, 0x01, 0x25, 0x01]),
            (19 + 212, &[0x25, 0x01, 0x25, 0x01]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn smart_health_information_temp_low() {
        setup();

        let mut subsys = Subsystem::new(SubsystemInfo::invalid());
        let ppid = subsys.add_port(PortType::Pcie(PciePort::new())).unwrap();
        let ctlrid = subsys.add_controller(ppid).unwrap();
        let twpid = subsys
            .add_port(PortType::TwoWire(TwoWirePort::new()))
            .unwrap();
        let mut mep = ManagementEndpoint::new(twpid);
        let ctlr = subsys.controller_mut(ctlrid);
        ctlr.set_temperature(Temperature::Kelvin(212));

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x7f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x84, 0xd7, 0xa6, 0xef
        ];

        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (15, &[0x00, 0x00, 0x01, 0x00]),
            (19, &[0x02, 0xd4, 0x00, 0x64]),
            (19 + 4, &[0x05, 0x26, 0x00, 0x00]),
            (19 + 200, &[0xd4, 0x00, 0xd4, 0x00]),
            (19 + 204, &[0xd4, 0x00, 0xd4, 0x00]),
            (19 + 208, &[0xd4, 0x00, 0xd4, 0x00]),
            (19 + 212, &[0xd4, 0x00, 0xd4, 0x00]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn error_information_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x0f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing DWORD 15

            // MIC
            0x01, 0xbd, 0xa2, 0xa3
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn error_information_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x0f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x6f, 0x7d, 0xfd, 0x6d
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn error_information() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x0f, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x44, 0x77, 0x3b, 0x9e
        ];

        #[rustfmt::skip]
        const RESP: [u8; 87] = [
            0x90, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0xb6, 0xce, 0x4e, 0x7f
        ];

        let resp = ExpectedRespChannel::new(&RESP);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn feature_identifiers_supported_and_effects_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x12, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing SQE DWORD 15

            // MIC
            0xfa, 0x21, 0x62, 0x5f
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn feature_identifiers_supported_and_effects_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x12, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x1d, 0x31, 0x5a, 0x2b
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }

    #[test]
    fn feature_identifiers_supported_and_effects() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aN0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x12, 0x00, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xbb, 0xa2, 0xe9, 0x2a
        ];

        let resp_fields: Vec<ExpectedField> = vec![(0, &[0x90]), (15, &[0x00, 0x00, 0x01, 0x00])];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async {
            mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp, async |_| Ok(()))
                .await
        });
    }
}
