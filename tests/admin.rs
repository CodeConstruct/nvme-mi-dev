// SPDX-License-Identifier: GPL-3.0-only
/*
 * Copyright (c) 2025 Code Construct
 */
mod common;

mod prohibited {
    use crate::common::{DeviceType, ExpectedRespChannel, RESP_INVALID_COMMAND, new_device, setup};
    use mctp::MsgIC;

    #[test]
    fn delete_io_submission_queue() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xef, 0x00, 0xd6, 0x6a
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }
}

mod identify {
    use crate::common::DeviceType;
    use crate::common::ExpectedField;
    use crate::common::ExpectedRespChannel;
    use crate::common::RESP_INVALID_COMMAND_SIZE;
    use crate::common::RESP_INVALID_PARAMETER;
    use crate::common::RelaxedRespChannel;
    use crate::common::new_device;
    use crate::common::setup;
    use mctp::MsgIC;

    #[test]
    fn controller_short() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing SQE DWORD 15

            // MIC
            0x8d, 0xc8, 0x56, 0xeb
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn controller_long() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Populated request data
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x02, 0x66, 0xb9, 0x3b
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn controller_unnatural_dofst() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Unnatural DOFST
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xb7, 0xc3, 0x93, 0x30
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn controller_large_dofst() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Large DOFST
            0x00, 0x10, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x9e, 0x2c, 0x6b, 0xe9
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn controller_unnatural_dlen() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Unnatural DLEN
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xf2, 0xe2, 0x2e, 0xc9
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn controller_large_dlen() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Large DLEN
            0x00, 0x00, 0x00, 0x00,
            0x04, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x6c, 0x38, 0x61, 0x22
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn controller_uncontained_range() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST + DLEN > 4096
            0x04, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x23, 0x19, 0x67, 0x94
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn controller_improper_dlen() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Improper DLEN
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x4e, 0x59, 0xe2, 0xfa
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn controller() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x9c, 0xd6, 0x53, 0xed
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (23, &[0x31, 0x30, 0x30, 0x30]), // SN
            (43, &[0x4d, 0x49, 0x44, 0x45, 0x56]), // MN
            (83, &[0x30, 0x30, 0x2e, 0x30, 0x30, 0x2e, 0x30, 0x31]), // FR
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn nvm_subsystem_controller_list() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x13, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x0a, 0x21, 0x8b, 0x19
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x01, 0x00]),
            (21, &[0x00, 0x00]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn namespace_invalid_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x12, 0x14, 0x1c, 0x57
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    #[ignore = "not yet implemented: Deal with broadcast NSID"]
    fn namespace_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xdc, 0xee, 0xe8, 0xf2
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn namespace_unallocated_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS0a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x49, 0xb0, 0xa7, 0x22
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn namespace_inactive() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x49, 0xb0, 0xa7, 0x22
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn namespace_active() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x49, 0xb0, 0xa7, 0x22
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            (27, &[0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            (35, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            (147, &[0x00, 0x00, 0x09, 0x00])
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn active_namespace_id_list_empty() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xff, 0xe7, 0x6f, 0x26
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn active_namespace_id_list_populated() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xff, 0xe7, 0x6f, 0x26
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x01, 0x00, 0x00, 0x00]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn active_namespace_id_list_constrained_empty() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xa4, 0x43, 0xd4, 0x53
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn namespace_identification_descriptor_list_bad_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xfe, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xe4, 0x7b, 0x6f, 0x4c
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn namespace_identification_descriptor_list_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xbf, 0xdf, 0xd4, 0x39
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn namespace_identification_descriptor_list_invalid_nsid_zero() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x71, 0x25, 0x20, 0x9c
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn namespace_identification_descriptor_list_invalid_nsid_exceeds() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x9c, 0xc9, 0xec, 0x02
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn namespace_identification_descriptor_list_unallocated_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xc7, 0x6d, 0x57, 0x77
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn namespace_identification_descriptor_list() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a1a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x2a, 0x81, 0x9b, 0xe9
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x03]),
            (20, &[0x10]),
            (39, &[0x04]),
            (40, &[0x01]),
            (41, &[0x00]),
            (42, &[0x00]),
            (43, &[0x00]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn allocated_namespace_id_list_populated() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x69, 0x10, 0xb7, 0xd2
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x01, 0x00, 0x00, 0x00]),
            (23, &[0x00, 0x00, 0x00, 0x00])
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn allocated_namespace_id_list_constrained_empty() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x32, 0xb4, 0x0c, 0xa7
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn allocated_namespace_id_list_constrained_bad_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xfe, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xfc, 0x4e, 0xf8, 0x02
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn allocated_namespace_id_list_constrained_broadcast_nsid() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xa7, 0xea, 0x43, 0x77
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }

    #[test]
    fn secondary_controller_list() {
        setup();

        let (mut mep, mut subsys) = new_device(DeviceType::P1p1tC1aNS1a0a);

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x15, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x3d, 0x35, 0x1f, 0x8a
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0; 4096]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, MsgIC(true), resp).await });
    }
}
