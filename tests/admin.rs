mod common;

mod prohibited {
    use crate::common::{ExpectedRespChannel, RESP_INVALID_COMMAND, new_simple_subsystem, setup};

    #[test]
    fn delete_io_submission_queue() {
        setup();

        let (mut mep, mut subsys) = new_simple_subsystem();

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xef, 0x00, 0xd6, 0x6a
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, true, resp).await });
    }
}

mod identify {
    use crate::common::ExpectedField;
    use crate::common::ExpectedRespChannel;
    use crate::common::RESP_INVALID_COMMAND_SIZE;
    use crate::common::RESP_INVALID_PARAMETER;
    use crate::common::RelaxedRespChannel;
    use crate::common::new_simple_subsystem;
    use crate::common::setup;

    #[test]
    fn controller_short() {
        setup();

        let (mut mep, mut subsys) = new_simple_subsystem();

        #[rustfmt::skip]
        const REQ: [u8; 67] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            // Missing SQE DWORD 15

            // MIC
            0x8d, 0xc8, 0x56, 0xeb
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, true, resp).await });
    }

    #[test]
    fn controller_long() {
        setup();

        let (mut mep, mut subsys) = new_simple_subsystem();

        #[rustfmt::skip]
        const REQ: [u8; 75] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Populated request data
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x02, 0x66, 0xb9, 0x3b
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_COMMAND_SIZE);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, true, resp).await });
    }

    #[test]
    fn controller_unnatural_dofst() {
        setup();

        let (mut mep, mut subsys) = new_simple_subsystem();

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Unnatural DOFST
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xb7, 0xc3, 0x93, 0x30
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, true, resp).await });
    }

    #[test]
    fn controller_large_dofst() {
        setup();

        let (mut mep, mut subsys) = new_simple_subsystem();

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Large DOFST
            0x00, 0x10, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x9e, 0x2c, 0x6b, 0xe9
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, true, resp).await });
    }

    #[test]
    fn controller_unnatural_dlen() {
        setup();

        let (mut mep, mut subsys) = new_simple_subsystem();

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Unnatural DLEN
            0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0xf2, 0xe2, 0x2e, 0xc9
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, true, resp).await });
    }

    #[test]
    fn controller_large_dlen() {
        setup();

        let (mut mep, mut subsys) = new_simple_subsystem();

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Large DLEN
            0x00, 0x00, 0x00, 0x00,
            0x04, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x6c, 0x38, 0x61, 0x22
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, true, resp).await });
    }

    #[test]
    fn controller_uncontained_range() {
        setup();

        let (mut mep, mut subsys) = new_simple_subsystem();

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST + DLEN > 4096
            0x04, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x23, 0x19, 0x67, 0x94
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, true, resp).await });
    }

    #[test]
    fn controller_improper_dlen() {
        setup();

        let (mut mep, mut subsys) = new_simple_subsystem();

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Improper DLEN
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x4e, 0x59, 0xe2, 0xfa
        ];

        let resp = ExpectedRespChannel::new(&RESP_INVALID_PARAMETER);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, true, resp).await });
    }

    #[test]
    fn controller() {
        setup();

        let (mut mep, mut subsys) = new_simple_subsystem();

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x9c, 0xd6, 0x53, 0xed
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (23, &[0x31, 0x30, 0x30, 0x30]), // SN
            (43, &[0x4d, 0x49, 0x44, 0x45, 0x56]), // MN
            (83, &[0x30, 0x30, 0x2e, 0x30, 0x30, 0x2e, 0x30, 0x31]), // FR
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, true, resp).await });
    }

    #[test]
    fn nvm_subsystem_controller_list() {
        setup();

        let (mut mep, mut subsys) = new_simple_subsystem();

        #[rustfmt::skip]
        const REQ: [u8; 71] = [
            0x10, 0x00, 0x00,
            0x06, 0x00, 0x00, 0x00,

            // SQE DWORD 1
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // DOFST
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,

            // Reserved
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // SQE DWORD 10
            0x13, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,

            // MIC
            0x0a, 0x21, 0x8b, 0x19
        ];

        #[rustfmt::skip]
        let resp_fields: Vec<ExpectedField> = vec![
            (0, &[0x90]),
            (19, &[0x01, 0x00]),
            (21, &[0x00, 0x00]),
        ];

        let resp = RelaxedRespChannel::new(resp_fields);
        smol::block_on(async { mep.handle_async(&mut subsys, &REQ, true, resp).await });
    }
}
